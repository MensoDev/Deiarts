@typeparam TRequest where TRequest : class
@using FluentValidation;

@code 
{
    [Parameter] 
    [EditorRequired]
    public required IValidator<TRequest> Validator { get; set; }

    [CascadingParameter] 
    public required EditContext EditContext { get; set; }

    private ValidationMessageStore _validationMessageStore = default!;

    protected override void OnInitialized()
    {
        if (EditContext is null)
        {
            throw new InvalidOperationException("Utilizar apenas dentro de um contexto de edição");
        }
        
        _validationMessageStore = new ValidationMessageStore(EditContext);
        EditContext.OnValidationRequested += (sender, eventArgs) => ValidateModel();
        EditContext.OnFieldChanged += (sender, eventArgs) => ValidateModel(validateSingleField: eventArgs.FieldIdentifier);
    }

    private void ValidateModel(FieldIdentifier? validateSingleField = null)
    {
        EditContext.NotifyValidationStateChanged();
        var validationFailures = Validator.Validate((TRequest)EditContext.Model).Errors;
        if (validateSingleField.HasValue)
        {
            _validationMessageStore.Clear(validateSingleField.Value);
        }
        else
        {
            _validationMessageStore.Clear();
        }

        foreach (var validationError in validationFailures)
        {
            GetParentObjectAndPropertyName(EditContext.Model, validationError.PropertyName, out var parentObject, out var propertyName);
            if (parentObject == null) continue;

            var fieldIdentifier = new FieldIdentifier(parentObject, propertyName);
            if (validateSingleField.HasValue)
            {
                if (validateSingleField.Equals(fieldIdentifier))
                {
                    _validationMessageStore.Add(validateSingleField.Value, validationError.ErrorMessage);
                }
            }
            else
            {
                _validationMessageStore.Add(fieldIdentifier, validationError.ErrorMessage);
            }
        }

        EditContext.NotifyValidationStateChanged();
        StateHasChanged();
    }

    private static void GetParentObjectAndPropertyName(
        object model,
        string propertyPath,
        out object? parentObject,
        out string propertyName)
    {
        var propertyPathParts = new Queue<string>(propertyPath.Split('.'));
        var modelType = model.GetType();
        while (propertyPathParts.Count > 1)
        {
            var name = propertyPathParts.Dequeue();

            var isCollection = name.Contains('[');
            var indexInCollection = -1;
            if (isCollection)
            {
                var bracketIndex = name.IndexOf('[');
                indexInCollection = int.Parse(name.Substring(bracketIndex + 1, name.Length - bracketIndex - 2));
                name = name.Remove(bracketIndex);
            }

            var propertyInfo = modelType.GetProperty(name)!;
            model = (propertyInfo.GetValue(model, null))!;

            if (isCollection)
            {
                var collection = ((IEnumerable<object>)model!).ToList();
                model = collection[indexInCollection];
                modelType = model.GetType();
            }
            else
            {
                modelType = propertyInfo.PropertyType;
            }
        }

        parentObject = model;
        propertyName = propertyPathParts.Dequeue();
    }

}